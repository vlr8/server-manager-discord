import time
from pprint import pprint
import requests
import common.proxies as proxies
import common.logger as logger
import random
from datetime import datetime
from http import cookies

COOKIE_STRING = """fbm_124024574287414=base_domain=.instagram.com; csrftoken=MFufzNI4i7z7ao10kFN5zlGsC2tjU86h; ds_user_id=26694167676; ps_n=1; ps_l=1; ig_did=FD19E7F2-5C00-4730-B2FE-4640634810E2; mid=ZsbQtAALAAHs041vw6CB3oQpslvS; datr=tNDGZknet3k7-WVRpQfgEe1X; dpr=1.5; wd=1280x613; sessionid=26694167676%3Ayw79JVR5H7dRrW%3A27%3AAYcnLJh5MqQa1TJCGz5n90l0PMRVGd_yyZSJexB8U-Tr; rur="LDC\05426694167676\0541776053320:01f7fbc1d240ebac4206d252a3969c022764cb246cba661c35640a7bf1f43d3e55cc33e9" """


logger = logger.get_logger('instagram_log')
use_proxies = False
# Initialize the proxy list from the proxies.txt file generated by PyProxy
proxy_list = []

with open('proxies.txt', 'r') as f:
    for line in f.readlines():
        username, password, host, port = line.strip().split(':')
        proxy_list.append({
            "http": f"http://{username}:{password}@{host}:{port}"
        })
    use_proxies = True

def get_proxy():
    # Select a random proxy from the list
    return random.choice(proxy_list)

def parse_cookies(cookie_string):
    cookie_jar = cookies.SimpleCookie()
    cookie_jar.load(cookie_string)
    return {key: morsel.value for key, morsel in cookie_jar.items()}

def parse_cookies_requests(cookie_string):
    jar = requests.cookies.RequestsCookieJar()
    for cookie in cookie_string.split(';'):
        if cookie.strip():
            key, value = cookie.strip().split('=', 1)
            jar.set(key.strip(), value.strip())
    return jar

def get_profile(username):
    # Parse the cookies
    cookies_dict = parse_cookies(COOKIE_STRING)

    headers = {
        'authority': 'www.instagram.com',
        'accept': '*/*',
        'accept-language': 'en-GB,en;q=0.9',
        'dnt': '1',
        'referer': 'https://www.instagram.com/the_sphere_hunter/?hl=en',
        'sec-ch-prefers-color-scheme': 'dark',
        'sec-ch-ua': '"Not.A/Brand";v="8", "Chromium";v="114", "Google Chrome";v="114"',
        'sec-ch-ua-full-version-list': '"Not.A/Brand";v="8.0.0.0", "Chromium";v="114.0.5735.133", "Google Chrome";v="114.0.5735.133"',
        'sec-ch-ua-mobile': '?0',
        'sec-ch-ua-platform': '"macOS"',
        'sec-ch-ua-platform-version': '"13.0.1"',
        'sec-fetch-dest': 'empty',
        'sec-fetch-mode': 'cors',
        'sec-fetch-site': 'same-origin',
        'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
        'viewport-width': '1440',
        'x-asbd-id': '129477',
        'x-csrftoken': 'MFufzNI4i7z7ao10kFN5zlGsC2tjU86h',
        'x-ig-app-id': '936619743392459',
        'x-ig-www-claim': '0',
        'x-mid': '1aap97aydv98b1gqna0zyngyml1omvk0p1jnvgns1lmisjmcl0kel',
        'x-requested-with': 'XMLHttpRequest',
        'x-web-device-id': '306F5F7E-9D9F-4B5B-AB15-E47509B13260',
    }
    
    # https://www.instagram.com/api/v1/users/web_profile_info/
    # https://www.instagram.com/carlos.henrique.reis.98/?__a=1
    # https://www.instagram.com/api/v1/feed/user/{username}/username/
    # resp = requests.get(f"https://www.instagram.com/api/v1/feed/user/{username}/username/?max_id=3593286537772770559_64272049122", 
    resp = requests.get(f"https://www.instagram.com/api/v1/feed/user/{username}/username/", 
                        #params=params, 
                        cookies = cookies_dict,
                        headers=headers, 
                        proxies=random.choice(proxy_list) if use_proxies else None)
    
    
    if resp.status_code != 200:
        logger.error('Rate limited, retrying in 60 seconds')
        time.sleep(60)
        return get_profile(username)
    
    try:
        data = resp.json()
        
    except requests.exceptions.JSONDecodeError:
        logger.error('JSONDecodeError, retrying in 60 seconds')
        time.sleep(60)
        return get_profile(username)
    
    # now we get the next_max_id for the next page of posts (can loop this for more pages)
    next_max_id = data['next_max_id']
    # and do request again with that number
    resp = requests.get(f"https://www.instagram.com/api/v1/feed/user/{username}/username/?max_id={next_max_id}", 
                        #params=params, 
                        cookies = cookies_dict,
                        headers=headers, 
                        proxies=random.choice(proxy_list) if use_proxies else None)
    
    
    if resp.status_code != 200:
        logger.error('Rate limited, retrying in 60 seconds')
        time.sleep(60)
        return get_profile(username)
    
    try:
        data = resp.json()
        
    except requests.exceptions.JSONDecodeError:
        logger.error('JSONDecodeError, retrying in 60 seconds')
        time.sleep(60)
        return get_profile(username)

    posts = []
    try:
        # data = data['data']['user']['edge_owner_to_timeline_media']['edges']
        posts_data = data['items']
        logger.info(f"Response for {username} returned {len(posts_data)} posts")
        for post in posts_data:
            posts.append({
                #'id': post['node']['shortcode'],
                'id': post['code'],
                #'url': f'https://www.instagram.com/p/{post["node"]["shortcode"]}/',
                'url': f'https://www.instagram.com/p/{post["code"]}/',
                # 'date': datetime.fromtimestamp(post['node']['taken_at_timestamp']),
                'date': datetime.fromtimestamp(post['taken_at']),
            })
    except Exception as e:
        logger.error('couldnt extract data for user ' + username)    
        
    return posts


class Instagram:
    def __init__(self, name, usernames, post_ids, channel_ids):
        self.name = name
        self.usernames = usernames
        self.post_ids = post_ids
        self.channel_ids = channel_ids
        self.url_only = True

    def fetch_posts(self):
        posts = []
        for username in self.usernames:
            logger.info(f"Fetching for {username}")
            posts += get_profile(username)

        return posts


def debug():
    data = get_profile('tr4nbie')
    pprint(data)


if __name__ == '__main__':
    debug()
